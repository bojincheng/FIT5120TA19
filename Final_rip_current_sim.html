<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rip Current Safety Guide</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: black;
            color: white;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .story-title {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            padding: 16px 24px;
            background: rgba(0,0,0,0.7);
            border-radius: 8px;
            text-align: center;
            border-bottom: 3px solid #22d3ee;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            max-width: 500px;
            z-index: 10;
        }
        
        .story-title h2 {
            font-size: 28px;
            font-weight: bold;
            color: white;
            margin: 0;
            letter-spacing: 0.5px;
        }
        
        .message {
            position: absolute;
            bottom: 96px;
            left: 50%;
            transform: translateX(-50%);
            padding: 16px 24px;
            background: rgba(0,0,0,0.8);
            border-radius: 8px;
            text-align: center;
            max-width: 500px;
            border: none;
            border-left: 3px solid #22d3ee;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 10;
        }
        
        .message p {
            font-size: 20px;
            font-weight: 500;
            margin: 0;
            letter-spacing: 0.3px;
        }
        
        .message .indicator {
            height: 4px;
            width: 96px;
            background-color: #22d3ee;
            margin: 8px auto 0;
            border-radius: 9999px;
        }
        
        .control-panel {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background-color: rgba(0,0,0,0.7);
            border-radius: 9999px;
            z-index: 10;
        }
        
        .button {
            background-color: transparent;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 9999px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        
        .button:hover {
            background-color: rgba(255,255,255,0.2);
        }
        
        .button svg {
            width: 20px;
            height: 20px;
        }
        
        .hotspot-info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 16px;
            background-color: rgba(0,0,0,0.8);
            color: white;
            border-radius: 8px;
            max-width: 384px;
            border: 1px solid #3b82f6;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 20;
        }
        
        .hotspot-info .close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: #9ca3af;
            cursor: pointer;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 9999px;
        }
        
        .hotspot-info .close:hover {
            color: white;
            background-color: #374151;
        }
        
        .hotspot-info p {
            font-size: 18px;
            margin: 0;
        }
        
        .info-panel {
            position: absolute;
            inset: 0;
            background-color: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 16px;
            z-index: 30;
        }
        
        .info-content {
            background-color: #111827;
            border-radius: 8px;
            max-width: 512px;
            padding: 24px;
            position: relative;
        }
        
        .info-content .close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: #9ca3af;
            cursor: pointer;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 9999px;
        }
        
        .info-content .close:hover {
            color: white;
            background-color: #374151;
        }
        
        .info-content h2 {
            font-size: 20px;
            font-weight: bold;
            color: #22d3ee;
            margin-bottom: 16px;
        }
        
        .info-content ol {
            list-style-type: decimal;
            padding-left: 20px;
            margin-top: 0;
            margin-bottom: 0;
        }
        
        .info-content li {
            margin-bottom: 12px;
            color: white;
        }
        
        .info-content .highlight {
            font-weight: 600;
        }
        
        .info-content .callout {
            margin-top: 24px;
            padding: 12px;
            background-color: rgba(30, 64, 175, 0.5);
            border-radius: 6px;
        }
        
        .info-content .callout p {
            color: #bfdbfe;
            font-size: 14px;
            margin: 0;
        }
        
        .info-content .footer {
            margin-top: 16px;
            color: #9ca3af;
            font-size: 14px;
        }
        
        .hidden {
            display: none;
        }
        
        .rip-type-selector {
            position: absolute;
            top: 80px;
            right: 16px;
            background-color: rgba(0,0,0,0.7);
            border-radius: 8px;
            padding: 12px;
            z-index: 10;
        }
        
        .rip-type-selector h3 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 16px;
            color: white;
        }
        
        .rip-type-button {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin-bottom: 8px;
            background-color: rgba(255,255,255,0.1);
            border: none;
            border-radius: 4px;
            color: white;
            text-align: left;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .rip-type-button:hover {
            background-color: rgba(255,255,255,0.2);
        }
        
        .rip-type-button.active {
            background-color: #2563eb;
        }
        
        .rip-type-button:last-child {
            margin-bottom: 0;
        }
        
        .wave-controls {
            position: absolute;
            top: 80px;
            left: 16px;
            background-color: rgba(0,0,0,0.7);
            border-radius: 8px;
            padding: 12px;
            z-index: 10;
        }
        
        .wave-controls h3 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 16px;
            color: white;
        }
        
        .wave-control-group {
            margin-bottom: 12px;
        }
        
        .wave-control-group label {
            display: block;
            margin-bottom: 4px;
            font-size: 14px;
            color: #e5e7eb;
        }
        
        .wave-control-group input[type="range"] {
            width: 100%;
            margin-bottom: 8px;
        }
        
        .wave-control-group:last-child {
            margin-bottom: 0;
        }
        
        .toggle-group {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .toggle-group label {
            margin-right: 8px;
            margin-bottom: 0;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #374151;
            transition: .4s;
            border-radius: 34px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: #2563eb;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }
        
        .wave-area {
            position: absolute;
            border: 2px dashed transparent;
            z-index: 5;
            cursor: pointer;
            transition: border-color 0.3s;
        }
        
        .wave-area:hover {
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .wave-area.highlighted {
            border-color: rgba(255, 255, 255, 0.8);
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .safe-zone-indicator {
            position: absolute;
            border: 2px dashed rgba(76, 175, 80, 0.7);
            background-color: rgba(76, 175, 80, 0.1);
            z-index: 4;
            pointer-events: none;
        }
        
        .danger-zone-indicator {
            position: absolute;
            border: 2px dashed rgba(244, 67, 54, 0.7);
            background-color: rgba(244, 67, 54, 0.1);
            z-index: 4;
            pointer-events: none;
        }
        
        .legend {
            position: absolute;
            bottom: 160px;
            right: 16px;
            background-color: rgba(0,0,0,0.7);
            border-radius: 8px;
            padding: 12px;
            z-index: 10;
        }
        
        .legend h3 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 16px;
            color: white;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .legend-color.safe {
            background-color: rgba(76, 175, 80, 0.5);
        }
        
        .legend-color.danger {
            background-color: rgba(244, 67, 54, 0.5);
        }
        
        .legend-text {
            font-size: 14px;
            color: white;
        }
        
        /* Back button styles */
        .back-button {
            position: absolute;
            top: 16px;
            left: 16px;
            padding: 8px 16px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            border: none;
            border-radius: 9999px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 16px;
            text-decoration: none;
            transition: background-color 0.2s;
            z-index: 11;
            width: fit-content;
        }

        .back-button:hover {
            background-color: rgba(0, 0, 0, 0.9);
        }

        .back-button svg {
            width: 20px;
            height: 20px;
        }
    </style>
</head>
<body>
    <div id="container">
        <a href="beach_rescue.html#rips" class="back-button">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
            </svg>
            Return to Rip Currents
        </a>
        <canvas id="simulation"></canvas>
        
        <div id="storyTitle" class="story-title">
            <h2 id="titleText">Rip Current Safety Guide</h2>
        </div>
        
        <div id="message" class="message">
            <p>Identifying safe and dangerous swimming areas</p>
            <div class="indicator"></div>
        </div>
        
        <div class="rip-type-selector">
            <h3>Rip Current Types</h3>
            <button id="channelRip" class="rip-type-button active">Channel Rip</button>
            <button id="flashRip" class="rip-type-button">Flash Rip</button>
            <button id="permanentRip" class="rip-type-button">Permanent Rip</button>
        </div>
        
        <div class="wave-controls">
            <h3>Wave Controls</h3>
            <div class="wave-control-group">
                <label for="waveHeight">Wave Height</label>
                <input type="range" id="waveHeight" min="0" max="100" value="50">
            </div>
            <div class="wave-control-group">
                <label for="waveSpeed">Wave Speed</label>
                <input type="range" id="waveSpeed" min="0" max="100" value="50">
            </div>
            <div class="wave-control-group">
                <div class="toggle-group">
                    <label for="showIndicators">Show Indicators</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showIndicators" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-group">
                    <label for="showLabels">Show Labels</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showLabels" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-group">
                    <label for="showSafeZones">Show Safe/Danger Zones</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showSafeZones" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
        </div>
        
        <div class="legend">
            <h3>Legend</h3>
            <div class="legend-item">
                <div class="legend-color safe"></div>
                <div class="legend-text">Safe Swimming Area</div>
            </div>
            <div class="legend-item">
                <div class="legend-color danger"></div>
                <div class="legend-text">Dangerous Area - Avoid</div>
            </div>
        </div>
        
        <div class="control-panel">
            <button id="resetBtn" class="button" title="Reset">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M23 4v6h-6"></path>
                    <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                </svg>
            </button>
            
            <button id="playBtn" class="button" title="Play/Pause">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polygon points="5 3 19 12 5 21 5 3"></polygon>
                </svg>
            </button>
            
            <button id="infoBtn" class="button" title="Information">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="16" x2="12" y2="12"></line>
                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                </svg>
            </button>
            
            <button id="fullscreenBtn" class="button" title="Fullscreen">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                </svg>
            </button>
        </div>
        
        <div id="hotspotInfo" class="hotspot-info hidden">
            <button class="close">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
            <p id="hotspotText"></p>
        </div>
        
        <div id="infoPanel" class="info-panel hidden">
            <div class="info-content">
                <button class="close">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
                
                <h2>How to Identify Rip Currents</h2>
                
                <ol>
                    <li>
                        <span class="highlight">Look for a gap in breaking waves</span> - A calm area between breaking waves often indicates a rip current.
                    </li>
                    <li>
                        <span class="highlight">Check for discolored water</span> - Rip currents may appear darker because they carry sand and sediment.
                    </li>
                    <li>
                        <span class="highlight">Watch for foam or debris moving seaward</span> - If objects are moving away from shore, a rip current may be present.
                    </li>
                    <li>
                        <span class="highlight">Notice a rippled surface</span> - Rip currents can create a rippled or choppy surface that looks different from surrounding water.
                    </li>
                    <li>
                        <span class="highlight">Observe a different water color</span> - Sometimes rip currents appear as a different color than surrounding water.
                    </li>
                </ol>
                
                <div class="callout">
                    <p>
                        When in doubt, ask a lifeguard! Always swim at beaches with lifeguards and follow posted warnings.
                    </p>
                </div>
                
                <div class="footer">
                    <p>
                        Click on the highlighted areas in the simulation to learn more about safe and dangerous swimming zones.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const canvas = document.getElementById('simulation');
        const container = document.getElementById('container');
        const titleText = document.getElementById('titleText');
        const messageEl = document.querySelector('.message p');
        const resetBtn = document.getElementById('resetBtn');
        const playBtn = document.getElementById('playBtn');
        const infoBtn = document.getElementById('infoBtn');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const hotspotInfo = document.getElementById('hotspotInfo');
        const hotspotText = document.getElementById('hotspotText');
        const hotspotCloseBtn = document.querySelector('.hotspot-info .close');
        const infoPanel = document.getElementById('infoPanel');
        const infoCloseBtn = document.querySelector('.info-content .close');
        
        // Rip type buttons
        const channelRipBtn = document.getElementById('channelRip');
        const flashRipBtn = document.getElementById('flashRip');
        const permanentRipBtn = document.getElementById('permanentRip');
        
        // Wave controls
        const waveHeightSlider = document.getElementById('waveHeight');
        const waveSpeedSlider = document.getElementById('waveSpeed');
        const showIndicatorsToggle = document.getElementById('showIndicators');
        const showLabelsToggle = document.getElementById('showLabels');
        const showSafeZonesToggle = document.getElementById('showSafeZones');
        
        // State variables
        let started = false;
        let paused = true;
        let animationTime = 0;
        let animationFrame = null;
        let isFullscreen = false;
        let waveAreas = [];
        let safeZones = [];
        let dangerZones = [];
        let activeHotspot = null;
        let currentRipType = 'channel'; // channel, flash, permanent
        
        // Wave control variables
        let waveHeight = 0.5; // 0-1 range
        let waveSpeed = 0.5; // 0-1 range
        let showIndicators = true;
        let showLabels = true;
        let showSafeZones = true;
        
        // Teen position variables
        let teenPosition = { x: 0.2, y: 0.35 }; // Start in safe area
        let teenInWater = true;
        let teenSwimmingInSafeZone = true;
        
        // Initialize canvas
        const ctx = canvas.getContext('2d');
        
        // Resize canvas to fill container
        function resizeCanvas() {
            const width = container.clientWidth;
            const height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
            
            // Redraw if animation is not running
            if (!started || paused) {
                drawSimulation();
            }
            
            // Update wave areas and zones
            createWaveAreas();
            createSafeAndDangerZones();
        }
        
        // Create clickable wave areas
        function createWaveAreas() {
            // Remove existing wave areas
            document.querySelectorAll('.wave-area').forEach(area => area.remove());
            
            // Create new wave areas based on current rip type
            const shoreLine = canvas.height * 0.25;
            
            if (currentRipType === 'channel') {
                const ripWidth = canvas.width * 0.2;
                const ripCenterX = canvas.width * 0.5;
                
                // Rip channel area
                createWaveArea(
                    ripCenterX - ripWidth/2,
                    shoreLine,
                    ripWidth,
                    canvas.height * 0.2,
                    "Rip Channel",
                    "This calm area between breaking waves is a channel rip current. The water looks darker and smoother because it's flowing outward. AVOID swimming here."
                );
                
                // Left sandbar area
                createWaveArea(
                    ripCenterX - ripWidth - canvas.width * 0.2,
                    shoreLine,
                    canvas.width * 0.2,
                    canvas.height * 0.1,
                    "Breaking Waves (Safe)",
                    "Waves breaking consistently over a sandbar. This pattern indicates shallower water and is generally safer for swimming."
                );
                
                // Right sandbar area
                createWaveArea(
                    ripCenterX + ripWidth/2,
                    shoreLine,
                    canvas.width * 0.2,
                    canvas.height * 0.1,
                    "Breaking Waves (Safe)",
                    "Waves breaking consistently over a sandbar. This pattern indicates shallower water and is generally safer for swimming."
                );
            } else if (currentRipType === 'flash') {
                const ripWidth = canvas.width * 0.1;
                const ripCenterX = canvas.width * 0.5;
                
                // Flash rip area
                createWaveArea(
                    ripCenterX - ripWidth/2,
                    shoreLine,
                    ripWidth,
                    canvas.height * 0.2,
                    "Flash Rip",
                    "This sudden disruption in the wave pattern is a flash rip. They form quickly after large waves or changing tides and can disappear just as fast. AVOID swimming here."
                );
                
                // Safe areas
                createWaveArea(
                    canvas.width * 0.2,
                    shoreLine,
                    canvas.width * 0.2,
                    canvas.height * 0.1,
                    "Normal Wave Pattern (Safe)",
                    "Regular, consistent wave patterns without disruptions are typically safer for swimming."
                );
            } else {
                const pierX = canvas.width * 0.7;
                const ripWidth = canvas.width * 0.15;
                
                // Permanent rip area
                createWaveArea(
                    pierX - ripWidth,
                    shoreLine,
                    ripWidth,
                    canvas.height * 0.2,
                    "Permanent Rip",
                    "This rip current forms alongside the pier structure. Permanent rips are consistently present and extremely dangerous. AVOID swimming near structures."
                );
                
                // Pier structure
                createWaveArea(
                    pierX - 15,
                    canvas.height * 0.2,
                    30,
                    canvas.height * 0.3,
                    "Pier Structure",
                    "Structures like piers, jetties, and rock formations create permanent rip currents. Never swim near these structures."
                );
                
                // Safe area
                createWaveArea(
                    canvas.width * 0.2,
                    shoreLine,
                    canvas.width * 0.2,
                    canvas.height * 0.1,
                    "Safe Swimming Area",
                    "This area away from the pier has consistent wave patterns and is safer for swimming."
                );
            }
        }
        
        // Create safe and danger zones
        function createSafeAndDangerZones() {
            // Remove existing zones
            document.querySelectorAll('.safe-zone-indicator, .danger-zone-indicator').forEach(zone => zone.remove());
            
            // Only create if toggle is on
            if (!showSafeZones) return;
            
            const shoreLine = canvas.height * 0.25;
            
            if (currentRipType === 'channel') {
                const ripWidth = canvas.width * 0.2;
                const ripCenterX = canvas.width * 0.5;
                
                // Danger zone - rip channel
                createDangerZone(
                    ripCenterX - ripWidth/2,
                    shoreLine,
                    ripWidth,
                    canvas.height * 0.4
                );
                
                // Safe zones - sandbars
                createSafeZone(
                    ripCenterX - ripWidth - canvas.width * 0.25,
                    shoreLine,
                    canvas.width * 0.25,
                    canvas.height * 0.2
                );
                
                createSafeZone(
                    ripCenterX + ripWidth/2,
                    shoreLine,
                    canvas.width * 0.25,
                    canvas.height * 0.2
                );
                
            } else if (currentRipType === 'flash') {
                const ripWidth = canvas.width * 0.1;
                const ripCenterX = canvas.width * 0.5;
                
                // Danger zone - flash rip
                createDangerZone(
                    ripCenterX - ripWidth/2,
                    shoreLine,
                    ripWidth,
                    canvas.height * 0.3
                );
                
                // Safe zone
                createSafeZone(
                    canvas.width * 0.15,
                    shoreLine,
                    canvas.width * 0.25,
                    canvas.height * 0.2
                );
                
            } else {
                const pierX = canvas.width * 0.7;
                const ripWidth = canvas.width * 0.15;
                
                // Danger zone - permanent rip and pier
                createDangerZone(
                    pierX - ripWidth,
                    shoreLine,
                    ripWidth + 30,
                    canvas.height * 0.4
                );
                
                // Safe zone - away from pier
                createSafeZone(
                    canvas.width * 0.15,
                    shoreLine,
                    canvas.width * 0.25,
                    canvas.height * 0.2
                );
            }
        }
        
        // Create a safe zone indicator
        function createSafeZone(x, y, width, height) {
            const zone = document.createElement('div');
            zone.className = 'safe-zone-indicator';
            zone.style.left = `${x}px`;
            zone.style.top = `${y}px`;
            zone.style.width = `${width}px`;
            zone.style.height = `${height}px`;
            container.appendChild(zone);
            safeZones.push(zone);
        }
        
        // Create a danger zone indicator
        function createDangerZone(x, y, width, height) {
            const zone = document.createElement('div');
            zone.className = 'danger-zone-indicator';
            zone.style.left = `${x}px`;
            zone.style.top = `${y}px`;
            zone.style.width = `${width}px`;
            zone.style.height = `${height}px`;
            container.appendChild(zone);
            dangerZones.push(zone);
        }
        
        // Create a clickable wave area
        function createWaveArea(x, y, width, height, title, description) {
            const area = document.createElement('div');
            area.className = 'wave-area';
            area.style.left = `${x}px`;
            area.style.top = `${y}px`;
            area.style.width = `${width}px`;
            area.style.height = `${height}px`;
            area.dataset.title = title;
            area.dataset.description = description;
            
            area.addEventListener('click', function() {
                document.querySelectorAll('.wave-area').forEach(a => a.classList.remove('highlighted'));
                this.classList.add('highlighted');
                
                hotspotText.innerHTML = `<strong>${this.dataset.title}</strong><br><br>${this.dataset.description}`;
                hotspotInfo.classList.remove('hidden');
            });
            
            container.appendChild(area);
            waveAreas.push(area);
        }
        
        // Event listeners
        window.addEventListener('resize', resizeCanvas);
        
        // Initialize
        resizeCanvas();
        
        // Reset simulation
        function resetSimulation() {
            started = true;
            paused = false;
            animationTime = 0;
            messageEl.textContent = "Identifying safe and dangerous swimming areas";
            
            // Reset wave controls
            waveHeight = 0.5;
            waveSpeed = 0.5;
            waveHeightSlider.value = 50;
            waveSpeedSlider.value = 50;
            
            // Update play button icon
            updatePlayButton();
            
            // Cancel animation frame if running
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
            
            // Start animation
            startAnimation();
            
            // Draw initial state
            drawSimulation();
        }
        
        // Toggle play/pause
        function togglePlayPause() {
            if (!started) {
                started = true;
                paused = false;
                messageEl.textContent = "Identifying safe and dangerous swimming areas";
                startAnimation();
                createWaveAreas();
                createSafeAndDangerZones();
            } else {
                paused = !paused;
                if (!paused) {
                    startAnimation();
                } else if (animationFrame) {
                    cancelAnimationFrame(animationFrame);
                    animationFrame = null;
                }
            }
            
            updatePlayButton();
        }
        
        // Update play button icon
        function updatePlayButton() {
            if (!started || paused) {
                playBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                `;
            } else {
                playBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="6" y="4" width="4" height="16"></rect>
                        <rect x="14" y="4" width="4" height="16"></rect>
                    </svg>
                `;
            }
        }
        
        // Toggle info panel
        function toggleInfo() {
            infoPanel.classList.toggle('hidden');
        }
        
        // Toggle fullscreen
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                container.requestFullscreen().catch(err => {
                    console.error(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                document.exitFullscreen();
            }
        }
        
        // Handle fullscreen change
        function handleFullscreenChange() {
            isFullscreen = !!document.fullscreenElement;
            updateFullscreenButton();
        }
        
        // Update fullscreen button icon
        function updateFullscreenButton() {
            if (isFullscreen) {
                fullscreenBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>
                    </svg>
                `;
            } else {
                fullscreenBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                    </svg>
                `;
            }
        }
        
        // Change rip current type
        function changeRipType(type) {
            currentRipType = type;
            
            // Update active button
            channelRipBtn.classList.remove('active');
            flashRipBtn.classList.remove('active');
            permanentRipBtn.classList.remove('active');
            
            if (type === 'channel') {
                channelRipBtn.classList.add('active');
                titleText.textContent = "Channel Rip Currents";
                messageEl.textContent = "Channel rips form between sandbars - swim on either side";
            } else if (type === 'flash') {
                flashRipBtn.classList.add('active');
                titleText.textContent = "Flash Rip Currents";
                messageEl.textContent = "Flash rips appear suddenly - swim in consistent wave areas";
            } else {
                permanentRipBtn.classList.add('active');
                titleText.textContent = "Permanent Rip Currents";
                messageEl.textContent = "Permanent rips form near structures - swim away from piers";
            }
            
            // Update wave areas and zones
            createWaveAreas();
            createSafeAndDangerZones();
            
            // Reset teen position to safe area
            resetTeenPosition();
            
            // Redraw simulation
            drawSimulation();
        }
        
        // Reset teen position to a safe area based on current rip type
        function resetTeenPosition() {
            if (currentRipType === 'channel') {
                // Position in safe area to the left of channel rip
                teenPosition = { x: 0.2, y: 0.35 };
            } else if (currentRipType === 'flash') {
                // Position in safe area away from flash rip
                teenPosition = { x: 0.2, y: 0.35 };
            } else {
                // Position in safe area away from permanent rip
                teenPosition = { x: 0.2, y: 0.35 };
            }
            teenInWater = true;
            teenSwimmingInSafeZone = true;
        }
        
        // Close hotspot info
        function closeHotspotInfo() {
            hotspotInfo.classList.add('hidden');
            activeHotspot = null;
            document.querySelectorAll('.wave-area').forEach(area => {
                area.classList.remove('highlighted');
            });
        }
        
        // Start animation loop
        function startAnimation() {
            const animate = () => {
                if (!paused) {
                    animationTime += 16; // ~60fps
                    drawSimulation();
                    animationFrame = requestAnimationFrame(animate);
                }
            };
            
            animationFrame = requestAnimationFrame(animate);
        }
        
        // Draw the simulation
        function drawSimulation() {
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Set up time variables
            const time = animationTime / 1000; // Convert to seconds
            
            // Enhanced color palette
            const colors = {
                // Sky colors
                skyTop: "#87CEEB",
                skyBottom: "#ADD8E6",
                
                // Water colors
                shallowWater: "#64B5F6",
                midWater: "#1976D2",
                deepWater: "#0D47A1",
                
                // Beach colors
                beach: "#F5DEB3",
                beachDark: "#E6C99F",
                
                // Rip current and zones
                ripCurrent: "#01579B",
                safeZone: "rgba(76, 175, 80, 0.1)",
                dangerZone: "rgba(244, 67, 54, 0.05)",
                
                // Character colors
                skin: "#FFD0A9",
                hair: "#8B4513",
                swimsuit: "#FF5252",
            };
            
            // Shoreline position (constant)
            const baseShoreLineValue = height * 0.25;
            const shoreLineValue = baseShoreLineValue;
            
            // Draw sky with enhanced gradient and sun
            const skyGradient = ctx.createLinearGradient(0, 0, 0, height * 0.2);
            skyGradient.addColorStop(0, colors.skyTop);
            skyGradient.addColorStop(1, colors.skyBottom);
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, width, height * 0.2);
            
            // Draw sun
            const sunX = width * 0.8;
            const sunY = height * 0.1;
            const sunRadius = 30;
            
            // Sun glow
            const sunGlow = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunRadius * 3);
            sunGlow.addColorStop(0, "rgba(255, 255, 200, 0.8)");
            sunGlow.addColorStop(0.2, "rgba(255, 255, 150, 0.4)");
            sunGlow.addColorStop(1, "rgba(255, 255, 100, 0)");
            
            ctx.fillStyle = sunGlow;
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunRadius * 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Sun itself
            ctx.fillStyle = "#FFFFA0";
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw beach with enhanced gradient and texture
            const beachGradient = ctx.createLinearGradient(0, height * 0.2, 0, height * 0.25);
            beachGradient.addColorStop(0, colors.beach);
            beachGradient.addColorStop(1, colors.beachDark);
            ctx.fillStyle = beachGradient;
            ctx.fillRect(0, height * 0.2, width, height * 0.05);
            
            // Add beach texture - using subtle gradient and lines
            for (let i = 0; i < 15; i++) {
                const y = height * 0.2 + (i / 15) * (height * 0.05);
                const lineWidth = 0.5 + Math.random() * 0.5;
                const alpha = 0.05 + Math.random() * 0.05;
                
                ctx.strokeStyle = `rgba(160, 140, 110, ${alpha})`;
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                ctx.moveTo(0, y + Math.sin(y * 0.1) * 2);
                
                // Create wavy line
                for (let x = 0; x < width; x += 20) {
                    const waveHeight = Math.sin(x * 0.01 + i) * 1.5;
                    ctx.lineTo(x, y + waveHeight);
                }
                
                ctx.stroke();
            }
            
            // Draw water with enhanced effects
            // Deep water base with more realistic gradient
            const waterGradient = ctx.createLinearGradient(0, shoreLineValue, 0, height);
            waterGradient.addColorStop(0, colors.shallowWater);
            waterGradient.addColorStop(0.3, colors.midWater);
            waterGradient.addColorStop(1, colors.deepWater);
            ctx.fillStyle = waterGradient;
            ctx.fillRect(0, shoreLineValue, width, height - shoreLineValue);
            
            // Draw underwater sand gradient at the shore
            const sandGradient = ctx.createLinearGradient(0, shoreLineValue, 0, shoreLineValue + height * 0.1);
            sandGradient.addColorStop(0, "rgba(245, 222, 179, 0.7)");
            sandGradient.addColorStop(1, "rgba(245, 222, 179, 0)");
            ctx.fillStyle = sandGradient;
            ctx.fillRect(0, shoreLineValue, width, height * 0.1);
            
            // Draw different types of rip currents based on selected type
            if (currentRipType === 'channel') {
                // Channel rip - gap between sandbars
                drawChannelRip(ctx, width, height, shoreLineValue, time);
            } else if (currentRipType === 'flash') {
                // Flash rip - temporary and sudden
                drawFlashRip(ctx, width, height, shoreLineValue, time);
            } else {
                // Permanent rip - near structures
                drawPermanentRip(ctx, width, height, shoreLineValue, time);
            }
            
            // Draw breaking waves with enhanced visibility
            drawBreakingWaves(ctx, width, height, shoreLineValue, time, currentRipType);
            
            // Draw foam particles in the water
            for (let i = 0; i < 60; i++) {
                const x = Math.random() * width;
                const yOffset = Math.sin(x * 0.05 + time * 2) * 5;
                const y = shoreLineValue + 10 + yOffset;
                const size = Math.random() * 3 + 1;
                const alpha = Math.random() * 0.5 + 0.3;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw teenager swimming
            const swimX = width * teenPosition.x;
            const swimY = height * teenPosition.y;
            
            drawTeenSwimming(ctx, swimX, swimY, time, colors);
            
            // Add safe zone indicator if teen is in safe zone
            if (teenSwimmingInSafeZone && showIndicators) {
                const safeRadius = 30 + Math.sin(time * 2) * 5;
                ctx.strokeStyle = "rgba(76, 175, 80, 0.7)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(swimX, swimY, safeRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                // "SAFE" text
                ctx.fillStyle = "rgba(76, 175, 80, 0.9)";
                ctx.font = "bold 14px Arial";
                ctx.textAlign = "center";
                ctx.fillText("SAFE", swimX, swimY - 40);
                ctx.textAlign = "start";
            }
            
            // Apply cinematic letterbox effect
            const letterboxHeight = height * 0.1;
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, width, letterboxHeight);
            ctx.fillRect(0, height - letterboxHeight, width, letterboxHeight);
        }
        
        // Draw channel rip current
        function drawChannelRip(ctx, width, height, shoreLine, time) {
            const ripWidth = width * 0.2;
            const ripCenterX = width * 0.5;
            
            // Rip current path with gradient
            const ripGradient = ctx.createLinearGradient(0, shoreLine, 0, height);
            ripGradient.addColorStop(0, "rgba(1, 87, 155, 0.2)");
            ripGradient.addColorStop(0.5, "rgba(1, 87, 155, 0.4)");
            ripGradient.addColorStop(1, "rgba(1, 87, 155, 0.6)");
            
            ctx.fillStyle = ripGradient;
            ctx.beginPath();
            ctx.moveTo(ripCenterX - ripWidth / 2, shoreLine);
            ctx.lineTo(ripCenterX + ripWidth / 2, shoreLine);
            ctx.lineTo(ripCenterX + ripWidth / 3, height);
            ctx.lineTo(ripCenterX - ripWidth / 3, height);
            ctx.closePath();
            ctx.fill();
            
            // Draw sandbars on either side (lighter areas)
            const sandbarGradient1 = ctx.createLinearGradient(0, shoreLine, 0, shoreLine + height * 0.15);
            sandbarGradient1.addColorStop(0, "rgba(245, 222, 179, 0.6)");
            sandbarGradient1.addColorStop(1, "rgba(245, 222, 179, 0)");
            
            ctx.fillStyle = sandbarGradient1;
            ctx.fillRect(ripCenterX - ripWidth - width * 0.2, shoreLine, width * 0.2, height * 0.15);
            ctx.fillRect(ripCenterX + ripWidth / 2, shoreLine, width * 0.2, height * 0.15);
            
            // Draw rip current flow visualization
            drawRipCurrentFlow(ctx, ripCenterX, ripWidth, shoreLine, height, time);
            
            // Add labels if enabled
            if (showLabels) {
                ctx.font = "bold 16px Arial";
                ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                ctx.fillText("Sandbar", ripCenterX - ripWidth - width * 0.1, shoreLine + 20);
                ctx.fillText("Sandbar", ripCenterX + ripWidth / 2 + width * 0.1, shoreLine + 20);
                ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                ctx.fillText("Rip Channel", ripCenterX - 40, shoreLine + 40);
                
                // Add arrow indicators for the rip current
                drawArrow(ctx, ripCenterX, shoreLine + 60, ripCenterX, shoreLine + 120, "rgba(255, 50, 50, 0.8)", 3);
                drawArrow(ctx, ripCenterX - 20, shoreLine + 80, ripCenterX - 20, shoreLine + 140, "rgba(255, 50, 50, 0.8)", 3);
                drawArrow(ctx, ripCenterX + 20, shoreLine + 80, ripCenterX + 20, shoreLine + 140, "rgba(255, 50, 50, 0.8)", 3);
            }
        }
        
        // Draw flash rip current
        function drawFlashRip(ctx, width, height, shoreLine, time) {
            // Flash rips are temporary and can appear suddenly
            // They're often narrower and more concentrated
            
            const ripWidth = width * 0.1;
            const ripCenterX = width * 0.5;
            
            // Make the rip pulsate to show its temporary nature
            const pulseFactor = 0.8 + Math.sin(time * 2) * 0.2;
            const adjustedRipWidth = ripWidth * pulseFactor;
            
            // Rip current path with gradient
            const ripGradient = ctx.createLinearGradient(0, shoreLine, 0, height);
            ripGradient.addColorStop(0, "rgba(1, 87, 155, 0.3)");
            ripGradient.addColorStop(0.5, "rgba(1, 87, 155, 0.5)");
            ripGradient.addColorStop(1, "rgba(1, 87, 155, 0.7)");
            
            ctx.fillStyle = ripGradient;
            ctx.beginPath();
            ctx.moveTo(ripCenterX - adjustedRipWidth / 2, shoreLine);
            ctx.lineTo(ripCenterX + adjustedRipWidth / 2, shoreLine);
            ctx.lineTo(ripCenterX + adjustedRipWidth / 4, height * 0.6);
            ctx.lineTo(ripCenterX - adjustedRipWidth / 4, height * 0.6);
            ctx.closePath();
            ctx.fill();
            
            // Draw more intense flow for flash rip
            for (let i = 0; i < 12; i++) {
                const xOffset = ((i - 6) / 6) * (adjustedRipWidth * 0.8);
                const x = ripCenterX + xOffset;
                const flowSpeed = 2.5 - Math.abs(xOffset) / (adjustedRipWidth * 0.4); // Faster in center
                
                // Create multiple particles flowing down the current
                for (let j = 0; j < 3; j++) {
                    const flowOffset = (time * flowSpeed + j * 0.33) % 1;
                    const yStart = shoreLine + flowOffset * (height * 0.35);
                    const yEnd = Math.min(yStart + 15, height * 0.6);
                    
                    // Adjust x position to follow the narrowing current
                    const progress = (yStart - shoreLine) / (height * 0.35);
                    const narrowingFactor = 1 - progress * 0.5;
                    const adjustedX = ripCenterX + xOffset * narrowingFactor;
                    
                    const alpha = 0.8 - flowOffset * 0.5;
                    
                    // Draw flow particle
                    ctx.globalAlpha = alpha;
                    ctx.strokeStyle = "#FFFFFF";
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(adjustedX, yStart);
                    ctx.lineTo(adjustedX, yEnd);
                    ctx.stroke();
                    
                    // Draw small arrow at the end
                    const arrowSize = 3;
                    ctx.beginPath();
                    ctx.moveTo(adjustedX, yEnd);
                    ctx.lineTo(adjustedX - arrowSize, yEnd - arrowSize);
                    ctx.lineTo(adjustedX + arrowSize, yEnd - arrowSize);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            ctx.globalAlpha = 1;
            
            // Add labels if enabled
            if (showLabels) {
                ctx.font = "bold 16px Arial";
                ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                ctx.fillText("Flash Rip", ripCenterX - 30, shoreLine + 40);
                
                // Add warning indicators
                const warningSize = 15 + Math.sin(time * 3) * 3;
                
                ctx.fillStyle = "rgba(255, 50, 50, 0.7)";
                ctx.beginPath();
                ctx.moveTo(ripCenterX - warningSize, shoreLine + 70);
                ctx.lineTo(ripCenterX, shoreLine + 70 - warningSize);
                ctx.lineTo(ripCenterX + warningSize, shoreLine + 70);
                ctx.closePath();
                ctx.fill();
                
                ctx.font = "bold 14px Arial";
                ctx.fillStyle = "#FFFFFF";
                ctx.textAlign = "center";
                ctx.fillText("!", ripCenterX, shoreLine + 67);
                ctx.textAlign = "start";
                
                // Add pulsating circle to indicate sudden appearance
                const pulseRadius = 30 + Math.sin(time * 4) * 15;
                ctx.strokeStyle = "rgba(255, 50, 50, 0.5)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(ripCenterX, shoreLine + 100, pulseRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // Draw permanent rip current
        function drawPermanentRip(ctx, width, height, shoreLine, time) {
            // Permanent rips form near structures like piers or jetties
            // Draw a pier/jetty structure
            const pierWidth = 30;
            const pierX = width * 0.7;
            
            // Draw pier/jetty
            ctx.fillStyle = "#8B4513";
            ctx.fillRect(pierX - pierWidth/2, height * 0.2, pierWidth, height * 0.8);
            
            // Draw pier supports
            for (let y = height * 0.25; y < height; y += 40) {
                ctx.fillRect(pierX - pierWidth/2 - 5, y, pierWidth + 10, 10);
            }
            
            // Draw rip current along the structure
            const ripWidth = width * 0.15;
            const ripCenterX = pierX - ripWidth/2;
            
            // Rip current path with gradient
            const ripGradient = ctx.createLinearGradient(0, shoreLine, 0, height);
            ripGradient.addColorStop(0, "rgba(1, 87, 155, 0.3)");
            ripGradient.addColorStop(0.5, "rgba(1, 87, 155, 0.5)");
            ripGradient.addColorStop(1, "rgba(1, 87, 155, 0.7)");
            
            ctx.fillStyle = ripGradient;
            ctx.beginPath();
            ctx.moveTo(pierX - ripWidth, shoreLine);
            ctx.lineTo(pierX, shoreLine);
            ctx.lineTo(pierX, height);
            ctx.lineTo(pierX - ripWidth * 0.7, height);
            ctx.closePath();
            ctx.fill();
            
            // Draw rip current flow visualization
            for (let i = 0; i < 10; i++) {
                const xOffset = ((i) / 10) * ripWidth;
                const x = pierX - xOffset;
                const flowSpeed = 1.5 - Math.abs(xOffset) / ripWidth; // Faster near structure
                
                // Create multiple particles flowing down the current
                for (let j = 0; j < 3; j++) {
                    const flowOffset = (time * flowSpeed + j * 0.33) % 1;
                    const yStart = shoreLine + flowOffset * (height - shoreLine);
                    const yEnd = Math.min(yStart + 20, height);
                    
                    // Adjust x position to follow the current
                    const progress = (yStart - shoreLine) / (height - shoreLine);
                    const narrowingFactor = 1 - progress * 0.3;
                    const adjustedX = x * narrowingFactor + pierX * (1 - narrowingFactor);
                    
                    const alpha = 0.7 - flowOffset * 0.5;
                    
                    // Draw flow particle
                    ctx.globalAlpha = alpha;
                    ctx.strokeStyle = "#FFFFFF";
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(adjustedX, yStart);
                    ctx.lineTo(adjustedX, yEnd);
                    ctx.stroke();
                    
                    // Draw small arrow at the end
                    const arrowSize = 3;
                    ctx.beginPath();
                    ctx.moveTo(adjustedX, yEnd);
                    ctx.lineTo(adjustedX - arrowSize, yEnd - arrowSize);
                    ctx.lineTo(adjustedX + arrowSize, yEnd - arrowSize);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            ctx.globalAlpha = 1;
            
            // Add labels if enabled
            if (showLabels) {
                ctx.font = "bold 16px Arial";
                ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                ctx.fillText("Pier", pierX - 15, height * 0.2 - 10);
                ctx.fillText("Permanent Rip", pierX - ripWidth/2 - 50, shoreLine + 40);
                
                // Add warning sign on pier
                ctx.fillStyle = "#FF0000";
                ctx.beginPath();
                ctx.moveTo(pierX - 15, height * 0.2 + 30);
                ctx.lineTo(pierX + 15, height * 0.2 + 30);
                ctx.lineTo(pierX, height * 0.2 + 10);
                ctx.closePath();
                ctx.fill();
                
                ctx.font = "bold 14px Arial";
                ctx.fillStyle = "#FFFFFF";
                ctx.textAlign = "center";
                ctx.fillText("!", pierX, height * 0.2 + 25);
                ctx.textAlign = "start";
                
                //  height * 0.2 + 25);
                ctx.textAlign = "start";
                
                // Add "DANGER" text
                ctx.font = "bold 14px Arial";
                ctx.fillStyle = "#FF0000";
                ctx.textAlign = "center";
                ctx.fillText("DANGER", pierX - ripWidth/2, shoreLine + 70);
                ctx.textAlign = "start";
                
                // Add arrows showing flow direction
                drawArrow(ctx, pierX - ripWidth/2, shoreLine + 100, pierX - ripWidth/2, shoreLine + 160, "rgba(255, 50, 50, 0.8)", 3);
                drawArrow(ctx, pierX - ripWidth/4, shoreLine + 120, pierX - ripWidth/4, shoreLine + 180, "rgba(255, 50, 50, 0.8)", 3);
            }
        }
        
        // Draw breaking waves with enhanced visibility
        function drawBreakingWaves(ctx, width, height, shoreLine, time, ripType) {
            // Apply wave height and speed from controls
            const adjustedWaveHeight = 8 + waveHeight * 12; // 8-20 range
            const adjustedWaveSpeed = 1 + waveSpeed * 3; // 1-4 range
            
            // Draw multiple layers of breaking waves
            const waveY = shoreLine + 5;
            
            // Different wave patterns based on rip type
            if (ripType === 'channel') {
                // Channel rip - gap in breaking waves
                const ripWidth = width * 0.2;
                const ripCenterX = width * 0.5;
                
                // Left side waves
                drawWaveSection(ctx, 0, ripCenterX - ripWidth/2, waveY, time, 1.0, adjustedWaveHeight, adjustedWaveSpeed);
                
                // Right side waves
                drawWaveSection(ctx, ripCenterX + ripWidth/2, width, waveY, time, 1.0, adjustedWaveHeight, adjustedWaveSpeed);
                
                // Reduced waves in the rip channel
                drawWaveSection(ctx, ripCenterX - ripWidth/2, ripCenterX + ripWidth/2, waveY, time, 0.2, adjustedWaveHeight, adjustedWaveSpeed);
                
                // Add visual indicator for the gap in waves
                if (showIndicators) {
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
                    ctx.setLineDash([5, 5]);
                    ctx.lineWidth = 2;
                    
                    // Draw lines indicating the gap
                    ctx.beginPath();
                    ctx.moveTo(ripCenterX - ripWidth/2, shoreLine);
                    ctx.lineTo(ripCenterX - ripWidth/2, shoreLine + 50);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(ripCenterX + ripWidth/2, shoreLine);
                    ctx.lineTo(ripCenterX + ripWidth/2, shoreLine + 50);
                    ctx.stroke();
                    
                    ctx.setLineDash([]);
                }
            } else if (ripType === 'flash') {
                // Flash rip - sudden disruption in wave pattern
                const ripWidth = width * 0.1;
                const ripCenterX = width * 0.5;
                const pulseFactor = 0.8 + Math.sin(time * 2) * 0.2;
                const adjustedRipWidth = ripWidth * pulseFactor;
                
                // Draw waves with a sudden disruption
                for (let x = 0; x < width; x += 10) {
                    // Skip or reduce waves in the flash rip area
                    const distFromRip = Math.abs(x - ripCenterX);
                    if (distFromRip < adjustedRipWidth/2) {
                        continue; // Skip waves in rip channel
                    }
                    
                    const waveHeight = adjustedWaveHeight + Math.sin(x * 0.05 + time * adjustedWaveSpeed) * 4;
                    const waveFoam = 3 + Math.sin(x * 0.1 + time) * 2;
                    
                    // Wave
                    ctx.fillStyle = "#FFFFFF";
                    ctx.beginPath();
                    ctx.ellipse(x, waveY, waveFoam, waveHeight, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Add visual indicator for the flash rip
                if (showIndicators) {
                    const flashOpacity = 0.3 + Math.sin(time * 4) * 0.2;
                    ctx.fillStyle = `rgba(255, 50, 50, ${flashOpacity})`;
                    ctx.beginPath();
                    ctx.moveTo(ripCenterX - adjustedRipWidth/2, shoreLine);
                    ctx.lineTo(ripCenterX + adjustedRipWidth/2, shoreLine);
                    ctx.lineTo(ripCenterX + adjustedRipWidth/4, shoreLine + 50);
                    ctx.lineTo(ripCenterX - adjustedRipWidth/4, shoreLine + 50);
                    ctx.closePath();
                    ctx.fill();
                }
            } else {
                // Permanent rip - waves disrupted near structure
                const pierX = width * 0.7;
                const ripWidth = width * 0.15;
                
                // Draw waves except near the pier
                for (let x = 0; x < width; x += 10) {
                    // Skip or reduce waves in the permanent rip area
                    if (x > pierX - ripWidth && x < pierX) {
                        continue; // Skip waves in rip area
                    }
                    
                    const waveHeight = adjustedWaveHeight + Math.sin(x * 0.05 + time * adjustedWaveSpeed) * 4;
                    const waveFoam = 3 + Math.sin(x * 0.1 + time) * 2;
                    
                    // Wave
                    ctx.fillStyle = "#FFFFFF";
                    ctx.beginPath();
                    ctx.ellipse(x, waveY, waveFoam, waveHeight, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Add visual indicator for the permanent rip
                if (showIndicators) {
                    ctx.strokeStyle = "rgba(255, 50, 50, 0.5)";
                    ctx.lineWidth = 3;
                    ctx.setLineDash([8, 4]);
                    
                    // Draw line indicating the danger zone
                    ctx.beginPath();
                    ctx.moveTo(pierX - ripWidth, shoreLine + 20);
                    ctx.lineTo(pierX, shoreLine + 20);
                    ctx.stroke();
                    
                    ctx.setLineDash([]);
                }
            }
        }
        
        // Draw a section of breaking waves
        function drawWaveSection(ctx, startX, endX, y, time, intensity, waveHeight, waveSpeed) {
            for (let x = startX; x < endX; x += 10) {
                const waveHeightVal = intensity * (waveHeight + Math.sin(x * 0.05 + time * waveSpeed) * 4);
                const waveFoam = intensity * (3 + Math.sin(x * 0.1 + time) * 2);
                
                if (waveHeightVal < 1) continue; // Skip very small waves
                
                // Wave
                ctx.fillStyle = "#FFFFFF";
                ctx.beginPath();
                ctx.ellipse(x, y, waveFoam, waveHeightVal, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Helper function to draw rip current flow
        function drawRipCurrentFlow(ctx, ripCenterX, ripWidth, shoreLine, height, time) {
            // Draw rip current flow lines
            ctx.strokeStyle = "#FFFFFF";
            ctx.lineWidth = 1.5;
            
            for (let i = 0; i < 8; i++) {
                const xOffset = ((i - 4) / 4) * (ripWidth * 0.8);
                const x = ripCenterX + xOffset;
                const flowSpeed = 1.5 - Math.abs(xOffset) / (ripWidth * 0.4); // Faster in center
                
                // Create multiple particles flowing down the current
                for (let j = 0; j < 3; j++) {
                    const flowOffset = (time * flowSpeed + j * 0.33) % 1;
                    const yStart = shoreLine + flowOffset * (height - shoreLine);
                    const yEnd = Math.min(yStart + 20, height);
                    
                    // Adjust x position to follow the narrowing current
                    const progress = (yStart - shoreLine) / (height - shoreLine);
                    const narrowingFactor = 1 - progress * 0.4;
                    const adjustedX = ripCenterX + xOffset * narrowingFactor;
                    
                    const alpha = 0.7 - flowOffset * 0.5;
                    
                    // Draw flow particle
                    ctx.globalAlpha = alpha;
                    ctx.beginPath();
                    ctx.moveTo(adjustedX, yStart);
                    ctx.lineTo(adjustedX, yEnd);
                    ctx.stroke();
                    
                    // Draw small arrow at the end
                    const arrowSize = 3;
                    ctx.beginPath();
                    ctx.moveTo(adjustedX, yEnd);
                    ctx.lineTo(adjustedX - arrowSize, yEnd - arrowSize);
                    ctx.lineTo(adjustedX + arrowSize, yEnd - arrowSize);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            ctx.globalAlpha = 1;
        }
        
        // Helper function to draw an arrow
        function drawArrow(ctx, fromX, fromY, toX, toY, color, width) {
            const headLength = 10;
            const angle = Math.atan2(toY - fromY, toX - fromX);
            
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            
            // Draw line
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            // Draw arrowhead
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI/6), toY - headLength * Math.sin(angle - Math.PI/6));
            ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI/6), toY - headLength * Math.sin(angle + Math.PI/6));
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }
        
        // Draw teenager swimming
        function drawTeenSwimming(ctx, x, y, time, colors) {
            const baseSize = 20;
            const swimCycle = time * 4;
            const legKick = Math.sin(swimCycle) * baseSize * 0.5;
            const armStroke = Math.cos(swimCycle) * baseSize * 0.5;
            
            // Draw shadow under water
            ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
            ctx.beginPath();
            ctx.ellipse(x, y + baseSize * 0.5, baseSize, baseSize * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw legs with kicking motion
            ctx.strokeStyle = colors.skin;
            ctx.lineWidth = baseSize * 0.25;
            
            // Left leg
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - baseSize * 0.5 - legKick, y + baseSize * 0.8);
            ctx.stroke();
            
            // Right leg
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + baseSize * 0.5 + legKick, y + baseSize * 0.8);
            ctx.stroke();
            
            // Draw swimsuit
            ctx.fillStyle = colors.swimsuit;
            ctx.beginPath();
            ctx.ellipse(x, y, baseSize * 0.5, baseSize * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw torso
            ctx.fillStyle = colors.skin;
            ctx.beginPath();
            ctx.ellipse(x, y - baseSize * 0.3, baseSize * 0.4, baseSize * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw head
            ctx.fillStyle = colors.skin;
            ctx.beginPath();
            ctx.arc(x, y - baseSize * 0.7, baseSize * 0.35, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw hair
            ctx.fillStyle = colors.hair;
            ctx.beginPath();
            ctx.arc(x, y - baseSize * 0.85, baseSize * 0.35, Math.PI, 0);
            ctx.fill();
            
            // Draw arms with swimming motion
            ctx.strokeStyle = colors.skin;
            ctx.lineWidth = baseSize * 0.2;
            
            // Left arm
            ctx.beginPath();
            ctx.moveTo(x - baseSize * 0.4, y - baseSize * 0.3);
            ctx.lineTo(x - baseSize * 0.8 - armStroke, y - baseSize * 0.1);
            ctx.stroke();
            
            // Right arm
            ctx.beginPath();
            ctx.moveTo(x + baseSize * 0.4, y - baseSize * 0.3);
            ctx.lineTo(x + baseSize * 0.8 + armStroke, y - baseSize * 0.1);
            ctx.stroke();
            
            // Draw face
            if (baseSize > 10) {
                // Eyes
                ctx.fillStyle = "#000";
                ctx.beginPath();
                ctx.ellipse(x - baseSize * 0.1, y - baseSize * 0.7, baseSize * 0.05, baseSize * 0.03, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.ellipse(x + baseSize * 0.1, y - baseSize * 0.7, baseSize * 0.05, baseSize * 0.03, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Mouth - happy
                ctx.beginPath();
                ctx.arc(x, y - baseSize * 0.55, baseSize * 0.1, 0.1, Math.PI - 0.1, false);
                ctx.stroke();
            }
            
            // Water splash effects around swimmer
            for (let i = 0; i < 5; i++) {
                const splashX = x + (Math.random() - 0.5) * baseSize * 3;
                const splashY = y + (Math.random() - 0.5) * baseSize * 2;
                const splashSize = Math.random() * baseSize * 0.2 + baseSize * 0.1;
                
                ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
                ctx.beginPath();
                ctx.arc(splashX, splashY, splashSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Event listeners
        resetBtn.addEventListener('click', resetSimulation);
        playBtn.addEventListener('click', togglePlayPause);
        infoBtn.addEventListener('click', toggleInfo);
        fullscreenBtn.addEventListener('click', toggleFullscreen);
        hotspotCloseBtn.addEventListener('click', closeHotspotInfo);
        infoCloseBtn.addEventListener('click', toggleInfo);
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        
        // Wave control event listeners
        waveHeightSlider.addEventListener('input', function() {
            waveHeight = this.value / 100;
        });
        
        waveSpeedSlider.addEventListener('input', function() {
            waveSpeed = this.value / 100;
        });
        
        showIndicatorsToggle.addEventListener('change', function() {
            showIndicators = this.checked;
        });
        
        showLabelsToggle.addEventListener('change', function() {
            showLabels = this.checked;
        });
        
        showSafeZonesToggle.addEventListener('change', function() {
            showSafeZones = this.checked;
            if (showSafeZones) {
                createSafeAndDangerZones();
            } else {
                document.querySelectorAll('.safe-zone-indicator, .danger-zone-indicator').forEach(zone => zone.remove());
            }
        });
        
        // Rip type buttons
        channelRipBtn.addEventListener('click', () => changeRipType('channel'));
        flashRipBtn.addEventListener('click', () => changeRipType('flash'));
        permanentRipBtn.addEventListener('click', () => changeRipType('permanent'));
        
        // Start the simulation automatically
        resetSimulation();
    </script>
</body>
</html>

